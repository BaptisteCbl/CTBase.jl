var documenterSearchIndex = {"docs":
[{"location":"api-solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"solution.jl\"]\nPrivate = false","category":"page"},{"location":"api-solution.html#CTBase.OptimalControlSolution","page":"Solution","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\nstate_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nstate_names::Union{Nothing, Vector{String}}: Default: nothing\nadjoint::Union{Nothing, Function}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\ncontrol_names::Union{Nothing, Vector{String}}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"callbacks.jl\"]\nPrivate = false","category":"page"},{"location":"api-callbacks.html#CTBase.CTCallback","page":"Callbacks","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.CTCallbacks","page":"Callbacks","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.PrintCallback","page":"Callbacks","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.PrintCallback-Tuple","page":"Callbacks","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.StopCallback","page":"Callbacks","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.StopCallback-Tuple","page":"Callbacks","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"Callbacks","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"Callbacks","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#API-for-developers","page":"Developers","title":"API for developers","text":"","category":"section"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Here is the doc of private functions and types.","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api-developers.html#CTBase.DescVarArg","page":"Developers","title":"CTBase.DescVarArg","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"constant"},{"location":"api-developers.html#CTBase.AbstractCTFunction","page":"Developers","title":"CTBase.AbstractCTFunction","text":"abstract type AbstractCTFunction <: Function\n\nAbstract type for functions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlModel","page":"Developers","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlSolution","page":"Developers","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractPlotNode","page":"Developers","title":"CTBase.AbstractPlotNode","text":"abstract type AbstractPlotNode\n\nAbstract node for plot.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.Control","page":"Developers","title":"CTBase.Control","text":"Type alias for a control.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotLeaf","page":"Developers","title":"CTBase.PlotLeaf","text":"struct PlotLeaf <: CTBase.AbstractPlotNode\n\nA leaf of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotNode","page":"Developers","title":"CTBase.PlotNode","text":"struct PlotNode <: CTBase.AbstractPlotNode\n\nA node of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PrintCallbacks","page":"Developers","title":"CTBase.PrintCallbacks","text":"Tuple of print callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.StopCallbacks","page":"Developers","title":"CTBase.StopCallbacks","text":"Tuple of stop callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.SymbolPlot","page":"Developers","title":"CTBase.SymbolPlot","text":"struct Tuple{Symbol, Integer}\n\nType alias for a plot element.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#Base.:\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Developers","title":"Base.:\\","text":"\\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> (:a, :b) \\ (:a,)\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Union{Tuple{time_dependence}, Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel{time_dependence}}} where time_dependence","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel{time_dependence}\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, InconsistentArgument}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::InconsistentArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, NotImplemented}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, UnauthorizedCall}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__callbacks-Tuple{}","page":"Developers","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__constraint_label-Tuple{}","page":"Developers","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__control_names-Tuple{Integer}","page":"Developers","title":"CTBase.__control_names","text":"__control_names(m::Integer) -> Any\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__criterion_type-Tuple{}","page":"Developers","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__display-Tuple{}","page":"Developers","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__fun_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Symbol\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is :autonomous, which means that the functions are considered time independent. The other possible time dependence is :nonautonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__init_interpolation-Tuple{}","page":"Developers","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#127#128\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"Developers","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__mu_strategy_ipopt-Tuple{}","page":"Developers","title":"CTBase.__mu_strategy_ipopt","text":"__mu_strategy_ipopt() -> String\n\n\nUsed to set the default value of the μ strategy of ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__ocp_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Symbol\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is :autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is :nonautonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__print_level_ipopt-Tuple{}","page":"Developers","title":"CTBase.__print_level_ipopt","text":"__print_level_ipopt() -> Int64\n\n\nUsed to set the default value of the print level of ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__state_names-Tuple{Integer}","page":"Developers","title":"CTBase.__state_names","text":"__state_names(n::Integer) -> Any\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__time_name-Tuple{}","page":"Developers","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time!-Tuple{Any, OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase._plot_time!","text":"_plot_time!(\n    p,\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nUpdate the plot p with the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time-Tuple{OptimalControlSolution, Integer, Symbol}","page":"Developers","title":"CTBase._plot_time","text":"_plot_time(\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n\n\nPlot a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time-Tuple{OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase._plot_time","text":"_plot_time(\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nPlot the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.constraint_type-NTuple{6, Any}","page":"Developers","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among  :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed (:other otherwise), together with the appropriate value (range or updated expression).\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u)\n(:boundary, :(2 * var\"x#0\"[1] ^ 2))\n\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u)\n(:boundary, :(2 * var\"x#f\"[1] ^ 2))\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u)\n(:boundary, :(var\"x#f\"[1] - var\"x#0\"[2]))\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u)\n(:control_range, Index(1))\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u)\n(:control_fun, :(2 * u[1] ^ 2))\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u)\n(:state_range, Index(1))\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u)\n(:state_fun, :(2 * x[1] ^ 2))\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u)\n(:mixed, :((2 * u[1] ^ 2) * x))\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u)\n:other\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctindice-Tuple{Integer}","page":"Developers","title":"CTBase.ctindice","text":"ctindice(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctupperscript-Tuple{Integer}","page":"Developers","title":"CTBase.ctupperscript","text":"ctupperscript(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturn expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturn x.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.get-Tuple{OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"CTBase.get","text":"get(\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Any\n\n\nGet the data for plotting.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.has-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains an x(t), x[i](t), x[i:j](t) or  x[i:p:j](t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.matrix2vec","page":"Developers","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"api-developers.html#CTBase.replace_call-NTuple{4, Any}","page":"Developers","title":"CTBase.replace_call","text":"replace_call(e, x, t, y) -> Any\n\n\nReplace calls in e such as x(t), x[i](t) or x[i:j](t) by y, y[i](t) or y[i:j](t), resp.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2  ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"Developers","title":"CTBase.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:ctNumber}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"RecipesBase.apply_recipe","text":"apply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}},\n    yy::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Vector{RecipesBase.RecipeData}\n\n\nReturn x and y for the plot of the optimal control solution sol  corresponding respectively to the argument xx and the argument yy.\n\nNotes.\n\nThe argument xx can be :time, :state, :control or :adjoint.\nIf xx is :time, then, a label is added to the plot.\nThe argument yy can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nMLStyle\nParameters\nPlots\nPrintf\nReexport\n\nList of all the exported names:\n\nAd\nAdjoint\nAdjoints\nAmbiguousDescription\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControlConstraint\nControlLaw\nControls\nDescription\nDimension\nDynamics\nFeedbackControl\nHamiltonian\nHamiltonianVectorField\nInconsistentArgument\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\nMayer\nMixedConstraint\nModel\nMultiplier\nNotImplemented\nOptimalControlModel\nOptimalControlSolution\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimes\nTimesDisc\nUnauthorizedCall\nVectorField\n_Time\nadd\nconstraint\nconstraint!\nconstraints_labels\ncontrol!\nctNumber\nctVector\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nisautonomous\nismax\nismin\nisnonautonomous\nmakeDescription\nnlp_constraints\nobjective!\nplot\nremove_constraint!\nstate!\ntime!\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase.jl","title":"CTBase.TimesDisc","text":"Type alias for a grid of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Adjoint","page":"CTBase.jl","title":"CTBase.Adjoint","text":"Type alias for an adjoint.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Adjoints","page":"CTBase.jl","title":"CTBase.Adjoints","text":"Type alias for a vector of adjoints.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase.jl","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase.jl","title":"CTBase.Dimension","text":"Type alias for a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase.jl","title":"CTBase.State","text":"Type alias for a state.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase.jl","title":"CTBase.States","text":"Type alias for a vector of states.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase.jl","title":"CTBase.Time","text":"Type alias for a time.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase.jl","title":"CTBase.Times","text":"Type alias for a vector of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase.jl","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase.jl","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api-parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"ctparser_utils.jl\", \"ctparser.jl\"]\nPrivate = false","category":"page"},{"location":"api-print.html#Print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-print.html","page":"Print","title":"Print","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"using CTBase\n\nocp = Model()\n\nstate!(ocp, 2, [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, [0, 1], \"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, [-1, 0])\nconstraint!(ocp, :final  , [ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\nconstraint!(ocp, :dynamics, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)\nnothing # hide","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-plot.html#Plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-plot.html#RecipesBase.plot-Tuple{OptimalControlSolution}","page":"Plot","title":"RecipesBase.plot","text":"plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    adjoint_style,\n    kwargs...\n) -> Any\n\n\nPlot the optimal control solution sol using the layout layout. The argument layout can be :group or :split (default).\n\nnote: Note\nThe keyword arguments state_style, control_style and adjoint_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the adjoint_style is passed to the plot of the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"using CTBase\n\n# create a solution\nn=2\nm=1\nt0=0.0\ntf=1.0\nx0=[-1.0, 0.0]\nxf=[0.0, 0.0]\na = x0[1]\nb = x0[2]\nC = [-(tf-t0)^3/6.0 (tf-t0)^2/2.0\n     -(tf-t0)^2/2.0 (tf-t0)]\nD = [-a-b*(tf-t0), -b]+xf\np0 = C\\D\nα = p0[1]\nβ = p0[2]\nx(t) = [a+b*(t-t0)+β*(t-t0)^2/2.0-α*(t-t0)^3/6.0, b+β*(t-t0)-α*(t-t0)^2/2.0]\np(t) = [α, -α*(t-t0)+β]\nu(t) = [p(t)[2]]\nobjective = 0.5*(α^2*(tf-t0)^3/3+β^2*(tf-t0)-α*β*(tf-t0)^2)\n#\nN=201\ntimes = range(t0, tf, N)\n#\n\nsol = OptimalControlSolution()\nsol.state_dimension = n\nsol.control_dimension = m\nsol.times = times\nsol.time_name=\"t\"\nsol.state = x\nsol.state_names = [ \"x\" * ctindices(i) for i ∈ range(1, n)]\nsol.adjoint = p\nsol.control = u\nsol.control_names = [ \"u\" ]\nsol.objective = objective\nsol.iterations = 0\nsol.stopping = :dummy\nsol.message = \"ceci est un test\"\nsol.success = true","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Let us consider we have defined an optimal control problem","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"ocp = Model()\n...","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"and solve it","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"sol = solve(ocp)","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"We can plot the solution with the default layout :split.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:split, size=(800, 600))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Or with the layout :group.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:group, size=(800, 300))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"You can specify some styles:","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, \n    state_style=(color=:blue,), \n    adjoint_style=(color=:black, linestyle=:dash),\n    control_style=(color=:red, linewidth=2),\n    size=(800, 600))","category":"page"},{"location":"api-description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-description.html","page":"Description","title":"Description","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"type"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y at the tuple of descriptions x if it is not already in the tuple x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.makeDescription-Tuple{Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.makeDescription","text":"makeDescription(\n    desc::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the description.\n\nExample\n\njulia> makeDescription((:a, :b))\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.makeDescription-Tuple{Vararg{Symbol}}","page":"Description","title":"CTBase.makeDescription","text":"makeDescription(desc::Symbol...) -> Tuple{Vararg{Symbol}}\n\n\nCreate a description from a tuple of symbols.\n\nExample\n\njulia> makeDescription(:a, :b)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"functions.jl\"]\nPrivate = false","category":"page"},{"location":"api-functions.html#CTBase.BoundaryConstraint","page":"Functions","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{state_dimension, constraint_dimension}\n\nFields\n\nf::Function\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nClassical calls\n\nstate dimension: 1\nconstraint dimension: 1\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> xf - x0)\njulia> B(0, 0, 1, 1)\n1\njulia> B(0, [0], 1, [1])\n1-element Vector{Int64}:\n 1\n\nstate dimension: 1\nconstraint dimension: 2\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> [xf - x0, t0 - tf])\njulia> B(0, 0, 1, 1)\n2-element Vector{Int64}:\n  1\n -1\njulia> B(0, [0], 1, [1])\nERROR: MethodError: Cannot `convert` an object of type \n  Vector{Any} to an object of type \n  Union{Real, AbstractVector{<:Real}}\n\nstate dimension: 2\nconstraint dimension: 1\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> tf - t0)\njulia> B(0, [1, 0], 1, [0, 1])\n1\n\nstate dimension: 2\nconstraint dimension: 2\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> [tf - t0, xf[1] - x0[2]])\njulia> B(0, [1, 0], 1, [1, 0])\n2-element Vector{Int64}:\n 1\n 1\n\nSpecific calls\n\nWhen giving a _Time for t0 and tf, the function takes a vector as input for x0 and xf and returns a vector as output.\n\nwarning: Warning\nTo use the specific call, you must construct the function with the keywords state_dimension and constraint_dimension.\n\nstate dimension: 1\nconstraint dimension: 1\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> xf - x0, \n    state_dimension=1, constraint_dimension=1)\njulia> B(_Time(0), 0, _Time(1), 1)\nERROR: MethodError: no method matching (::BoundaryConstraint{1, 1})(::_Time, ::Int64, \n::_Time, ::Int64)\njulia> B(_Time(0), [0], _Time(1), [1])\n1-element Vector{Int64}:\n 1\n\nstate dimension: 1\nconstraint dimension: 2\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> [xf - x0, t0 - tf], \n    state_dimension=1, constraint_dimension=2)\njulia> B(_Time(0), 0, _Time(1), 1)\nERROR: MethodError: no method matching (::BoundaryConstraint{1, 2})(::_Time, ::Int64, \n::_Time, ::Int64)\njulia> B(_Time(0), [0], _Time(1), [1])\n2-element Vector{Int64}:\n  1\n -1\n\nstate dimension: 2\nconstraint dimension: 1\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> tf - t0, \n    state_dimension=2, constraint_dimension=1)\njulia> B(_Time(0), [1, 0], _Time(1), [0, 1])\n1-element Vector{Int64}:\n 1\n\nstate dimension: 2\nconstraint dimension: 2\n\njulia> B = BoundaryConstraint((t0, x0, tf, xf) -> [tf - t0, xf[1] - x0[2]], \n    state_dimension=2, constraint_dimension=2)\njulia> B(_Time(0), [1, 0], _Time(1), [1, 0])\n2-element Vector{Int64}:\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.ControlConstraint","page":"Functions","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, control_dimension, constraint_dimension}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.ControlLaw","page":"Functions","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence}\n\nFields\n\nf::Function\n\nThe function f must be of the form f(t, x, p, args...; kwargs...) or f(x, p, args...; kwargs...) depending on  the time dependence of the optimal control problem.\n\nnote: Note\nOnly classical usage.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Dynamics","page":"Functions","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, state_dimension, control_dimension}\n\nFields\n\nf::Function\n\nSimilar to Lagrange, but the function f is assumed to return a vector of the same dimension as the state x.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.FeedbackControl","page":"Functions","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence}\n\nFields\n\nf::Function\n\nThe function f must be of the form f(t, x, args...; kwargs...) or f(x, args...; kwargs...) depending on  the time dependence of the optimal control problem.\n\nnote: Note\nOnly classical usage.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Hamiltonian","page":"Functions","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, state_dimension}\n\nFields\n\nf::Function\n\nThe default value for time_dependence is :autonomous.\n\nwarning: Warning\nWhen the state and adjoint are of dimension 1, consider x and p as scalars.\n\nClassical calls\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> H = Hamiltonian((x, p) -> x + p)\njulia> H(1, 1)\n2\njulia> H([1], [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\njulia> H = Hamiltonian((x, p) -> x + p, time_dependence=:autonomous)\njulia> H(1, 1)\n2\njulia> H([1], [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> H = Hamiltonian((t, x, p) -> x + p, time_dependence=:nonautonomous)\njulia> H(1, 1, 1)\n2\njulia> H(1, [1], [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\n\nstate dimension: 2\ntime dependence: autonomous\n\njulia> H = Hamiltonian((x, p) -> x[1]^2 + p[2]^2) # or time_dependence=:autonomous\njulia> H([1, 0], [0, 1])\n2\n\nstate dimension: 2\ntime dependence: nonautonomous\n\njulia> H = Hamiltonian((t, x, p) -> t + x[1]^2 + p[2]^2, time_dependence=:nonautonomous)\njulia> H(1, [1, 0], [0, 1])\n3\n\nSpecific calls\n\nWhen giving a _Time for t, the function takes a vector as input for x and p.\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> H = Hamiltonian((x, p) -> x + p, state_dimension=1)\njulia> H(_Time(0), 1, 1)\nERROR: MethodError: no method matching (::Hamiltonian{:autonomous, 1})(::CTBase._Time, ::Int64, ::Int64)\njulia> H(_Time(0), [1], [1])\n2\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> H = Hamiltonian((t, x, p) -> t + x + p, state_dimension=1, time_dependence=:nonautonomous)\njulia> H(_Time(1), 1, 1)\nERROR: MethodError: no method matching (::Hamiltonian{:nonautonomous, 1})(::CTBase._Time, ::Int64, ::Int64)\njulia> H(_Time(1), [1], [1])\n3\n\nstate dimension: 2\ntime dependence: autonomous\n\njulia> H = Hamiltonian((x, p) -> x[1]^2 + p[2]^2, state_dimension=2)\njulia> H(_Time(0), [1, 0], [0, 1])\n2\n\nstate dimension: 2\ntime dependence: nonautonomous\n\njulia> H = Hamiltonian((t, x, p) -> t + x[1]^2 + p[2]^2, state_dimension=2, time_dependence=:nonautonomous)\njulia> H(_Time(1), [1, 0], [0, 1])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.HamiltonianVectorField","page":"Functions","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, state_dimension}\n\nFields\n\nf::Function\n\nThe default value for time_dependence is :autonomous.\n\nwarning: Warning\nWhen the state and adjoint are of dimension 1, consider x and p as scalars.\n\nClassical calls\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x + p, x - p])\njulia> Hv(1, 1)\n2-element Vector{Int64}:\n 2\n 0\njulia> Hv([1], [1])\nERROR: MethodError: Cannot `convert` an object of type \n  Vector{Vector{Int64}} to an object of type \n  AbstractVector{<:Real}\njulia> Hv = HamiltonianVectorField((x, p) -> [x + p, x - p], time_dependence=:autonomous)\njulia> Hv(1, 1)\n2-element Vector{Int64}:\n 2\n 0\njulia> Hv([1], [1])\nERROR: MethodError: Cannot `convert` an object of type \n  Vector{Vector{Int64}} to an object of type \n  AbstractVector{<:Real}\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> Hv = HamiltonianVectorField((t, x, p) -> [x + p, x - p], time_dependence=:nonautonomous)\njulia> Hv(1, 1, 1)\n2-element Vector{Int64}:\n 2\n 0\njulia> Hv(1, [1], [1])\nERROR: MethodError: Cannot `convert` an object of type \n  Vector{Vector{Int64}} to an object of type \n  AbstractVector{<:Real}\n\nstate dimension: 2\ntime dependence: autonomous\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2 + p[2]^2, x[2]^2 - p[1]^2]) # or time_dependence=:autonomous\njulia> Hv([1, 0], [0, 1])\n2-element Vector{Int64}:\n 2\n 0\n\nstate dimension: 2\ntime dependence: nonautonomous\n\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t + x[1]^2 + p[2]^2, x[2]^2 - p[1]^2], time_dependence=:nonautonomous)\njulia> Hv(1, [1, 0], [0, 1])\n2-element Vector{Int64}:\n 3\n 0\n\nSpecific calls\n\nWhen giving a _Time for t, the function takes a vector as input for x and p.\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x + p, x - p], state_dimension=1)\njulia> Hv(_Time(0), 1, 1)\nERROR: MethodError: no method matching (::HamiltonianVectorField{:autonomous, 1})(::CTBase._Time, ::Int64, ::Int64)\njulia> Hv(_Time(0), [1], [1])\n2-element Vector{Int64}:\n 2\n 0\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t + x + p, x - p], state_dimension=1, time_dependence=:nonautonomous)\njulia> Hv(_Time(1), 1, 1)\nERROR: MethodError: no method matching (::HamiltonianVectorField{:nonautonomous, 1})(::CTBase._Time, ::Int64, ::Int64)\njulia> Hv(_Time(1), [1], [1])\n2-element Vector{Int64}:\n 3\n 0\n\nstate dimension: 2\ntime dependence: autonomous\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2 + p[2]^2, x[2]^2 - p[1]^2], state_dimension=2)\njulia> Hv(_Time(0), [1, 0], [0, 1])\n2-element Vector{Int64}:\n 2\n 0\n\nstate dimension: 2\ntime dependence: nonautonomous\n\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t + x[1]^2 + p[2]^2, x[2]^2 - p[1]^2], state_dimension=2, time_dependence=:nonautonomous)\njulia> Hv(_Time(1), [1, 0], [0, 1])\n2-element Vector{Int64}:\n 3\n 0\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Lagrange","page":"Functions","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, state_dimension, control_dimension}\n\nFields\n\nf::Function\n\nThe default value for time_dependence is :autonomous.\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nClassical calls\n\nstate dimension: 1\ncontrol dimension: 1\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x + u) # or time_dependence=:autonomous\njulia> L(1, 1)\n2\njulia> L([1], [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\n\nstate dimension: 1\ncontrol dimension: 1\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> x + u, time_dependence=:nonautonomous)\njulia> L(1, 1, 1)\n2\njulia> L(1, [1], [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\n\nstate dimension: 2\ncontrol dimension: 1\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x[1]^2 + u^2) # or time_dependence=:autonomous\njulia> L([1, 2], 1)\n2\n\nstate dimension: 2\ncontrol dimension: 1\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> x[1]^2 + u^2, time_dependence=:nonautonomous)\njulia> L(1, [1, 2], 1)\n2\n\nstate dimension: 1\ncontrol dimension: 2\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x^2 + u[2]^2) # or time_dependence=:autonomous\njulia> L(1, [1, 2])\n5\n\nstate dimension: 1\ncontrol dimension: 2\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> t + x^2 + u[2]^2, time_dependence=:nonautonomous)\njulia> L(1, 1, [1, 2])\n6\n\nstate dimension: 2\ncontrol dimension: 2\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x[1]^2 + u[2]^2) # or time_dependence=:autonomous\njulia> L([1, 2], [1, 2])\n5\n\nstate dimension: 2\ncontrol dimension: 2\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> t + x[1]^2 + u[2]^2, time_dependence=:nonautonomous)\njulia> L(1, [1, 2], [1, 2])\n6\n\nSpecific calls\n\nstate dimension: 1\ncontrol dimension: 1\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x + u, state_dimension=1, control_dimension=1) # or time_dependence=:autonomous\njulia> L(_Time(1), 1, 1)\nERROR: MethodError: no method matching (::Lagrange{:autonomous, 0, 0})(::CTBase._Time, ::Int64, ::Int64)\njulia> L(_Time(1), [1], [1])\n2\n\nstate dimension: 1\ncontrol dimension: 1\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> t + x + u, state_dimension=1, control_dimension=1, time_dependence=:nonautonomous)\njulia> L(_Time(1), 1, 1)\nERROR: MethodError: no method matching (::Lagrange{:nonautonomous, 0, 0})(::CTBase._Time, ::Int64, ::Int64)\njulia> L(_Time(1), [1], [1])\n3\n\nstate dimension: 2\ncontrol dimension: 1\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x[1]^2 + u^2, state_dimension=2, control_dimension=1) # or time_dependence=:autonomous\njulia> L(_Time(1), [1, 2], 1)\nERROR: MethodError: no method matching (::Lagrange{:autonomous, 0, 0})(::CTBase._Time, ::Vector{Int64}, ::Int64)\njulia> L(_Time(1), [1, 2], [1])\n2\n\nstate dimension: 2\ncontrol dimension: 1\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> t + x[1]^2 + u^2, state_dimension=2, control_dimension=1, time_dependence=:nonautonomous)\njulia> L(_Time(1), [1, 2], 1)\nERROR: MethodError: no method matching (::Lagrange{:nonautonomous, 0, 0})(::CTBase._Time, ::Vector{Int64}, ::Int64)\njulia> L(_Time(1), [1, 2], [1])\n3\n\nstate dimension: 1\ncontrol dimension: 2\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x^2 + u[2]^2, state_dimension=1, control_dimension=2) # or time_dependence=:autonomous\njulia> L(_Time(1), 1, [1, 2])\nERROR: MethodError: no method matching (::Lagrange{:autonomous, 0, 0})(::CTBase._Time, ::Int64, ::Vector{Int64})\njulia> L(_Time(1), [1], [1, 2])\n5\n\nstate dimension: 1\ncontrol dimension: 2\ntime dependence: nonautonomous\n\njulia> L = Lagrange((t, x, u) -> t + x^2 + u[2]^2, state_dimension=1, control_dimension=2, time_dependence=:nonautonomous)\njulia> L(_Time(1), 1, [1, 2])\nERROR: MethodError: no method matching (::Lagrange{:nonautonomous, 0, 0})(::CTBase._Time, ::Int64, ::Vector{Int64})\njulia> L(_Time(1), [1], [1, 2])\n6\n\nstate dimension: 2\ncontrol dimension: 2\ntime dependence: autonomous\n\njulia> L = Lagrange((x, u) -> x[1]^2 + u[2]^2, state_dimension=2, control_dimension=2) # or time_dependence=:autonomous\njulia> L(_Time(1), [1, 2], [1, 2])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Mayer","page":"Functions","title":"CTBase.Mayer","text":"struct Mayer{state_dimension}\n\nFields\n\nf::Function\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nClassical calls\n\nstate dimension: 1\n\njulia> G = Mayer((t0, x0, tf, xf) -> xf - x0)\njulia> G(0, 0, 1, 1)\n1\njulia> G(0, [0], 1, [1])\nERROR: MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Real\n\nstate dimension: 2\n\njulia> G = Mayer((t0, x0, tf, xf) -> tf - t0)\njulia> G(0, [1, 0], 1, [0, 1])\n1\n\nSpecific calls\n\nWhen giving a _Time for t0 and tf, the function takes a vector as input for x0 and xf.\n\nwarning: Warning\nTo use the specific call, you must construct the function with the keyword state_dimension.\n\nstate dimension: 1\n\njulia> G = Mayer((t0, x0, tf, xf) -> xf - x0, state_dimension=1)\njulia> G(_Time(0), 0, _Time(1), 1)\nERROR: MethodError: no method matching (:Mayer{1})(::CTBase._Time, ::Int64, ::CTBase._Time, ::Int64)\njulia> G(_Time(0), [0], _Time(1), [1])\n1\n\nstate dimension: 2\n\njulia> G = Mayer((t0, x0, tf, xf) -> tf - t0, state_dimension=2)\njulia> G(_Time(0), [1, 0], _Time(1), [0, 1])\n1\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.MixedConstraint","page":"Functions","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, state_dimension, control_dimension, constraint_dimension}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Multiplier","page":"Functions","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence}\n\nFields\n\nf::Function\n\nThe function f must be of the form f(t, x, p, args...; kwargs...) or f(x, p, args...; kwargs...) depending on  the time dependence of the optimal control problem.\n\nnote: Note\nOnly classical usage.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.StateConstraint","page":"Functions","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, state_dimension, constraint_dimension}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.VectorField","page":"Functions","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, state_dimension}\n\nFields\n\nf::Function\n\nThe default value for time_dependence is :autonomous.\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nClassical calls\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> V = VectorField(x -> 2x) # or time_dependence=:autonomous\njulia> V(1)\n2\njulia> V([1])\n1-element Vector{Int64}:\n 2\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> V = VectorField((t, x) -> t+2x, time_dependence=:nonautonomous)\njulia> V(1, 1)\n3\n\nstate dimension: 2\ntime dependence: autonomous\n\njulia> V = VectorField(x -> [x[1]^2, x[2]^2]) # or time_dependence=:autonomous\njulia> V([1, 0])\n2-element Vector{Int64}:\n 1\n 0\n\nstate dimension: 2\ntime dependence: nonautonomous\n\njulia> V = VectorField((t, x) -> [t + x[1]^2, x[2]^2], time_dependence=:nonautonomous)\njulia> V(1, [1, 0])\n2-element Vector{Int64}:\n 2\n 0\n\nSpecific calls\n\nstate dimension: 1\ntime dependence: autonomous\n\njulia> V = VectorField(x -> 2x, state_dimension=1) # or time_dependence=:autonomous\njulia> V(_Time(0), 1)\nERROR: MethodError: no method matching (::VectorField{:autonomous, 1})(::CTBase._Time, ::Int64)\njulia> V(_Time(0), [1])\n1-element Vector{Int64}:\n 2\n\nstate dimension: 1\ntime dependence: nonautonomous\n\njulia> V = VectorField((t, x) -> t+2x, state_dimension=1, time_dependence=:nonautonomous)\njulia> V(_Time(0), 1)\nERROR: MethodError: no method matching (::VectorField{:nonautonomous, 1})(::CTBase._Time, ::Int64)\njulia> V(_Time(1), [1])\n1-element Vector{Int64}:\n 3\n\nstate dimension: N>1\ntime dependence: autonomous\n\njulia> V = VectorField(x -> [x[1]^2, -x[2]^2], state_dimension=2) # or time_dependence=:autonomous\njulia> V(_Time(0), [1, 2])\n2-element Vector{Int64}:\n  1\n -4\n\nstate dimension: N>1\ntime dependence: nonautonomous\n\njulia> V = VectorField((t, x) -> [t + x[1]^2, -x[2]^2], state_dimension=2, time_dependence=:nonautonomous)\njulia> V(_Time(1), [1, 2])\n2-element Vector{Int64}:\n  2\n -4\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase._Time","page":"Functions","title":"CTBase._Time","text":"struct _Time\n\nFields\n\nvalue::Real\n\nUsed to define typed methods to make specific calls.\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#Exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"exceptions.jl\"]\nPrivate = false","category":"page"},{"location":"api-exceptions.html#CTBase.AmbiguousDescription","page":"Exceptions","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.CTException","page":"Exceptions","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.InconsistentArgument","page":"Exceptions","title":"CTBase.InconsistentArgument","text":"struct InconsistentArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectArgument","page":"Exceptions","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectMethod","page":"Exceptions","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectOutput","page":"Exceptions","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.NotImplemented","page":"Exceptions","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.UnauthorizedCall","page":"Exceptions","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-model.html","page":"Model","title":"Model","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"model.jl\"]\nPrivate = false","category":"page"},{"location":"api-model.html#CTBase.Index","page":"Model","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#CTBase.OptimalControlModel","page":"Model","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\ninitial_time::Union{Nothing, Real}: Default: nothing\nfinal_time::Union{Nothing, Real}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_names::Union{Nothing, Vector{String}}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(; time_dependence) -> OptimalControlModel{:autonomous}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\ntime_dependence: either :autonomous or :nonautonomous. Default is :autonomous.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(time_dependence=:nonautonomous)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint!","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, CTBase.var\"#145#146\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#147#148\", Any, Any}\n\n\nAdd an :initial, :final, :control or :state box constraint (whole range).\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-2","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val\n) -> Any\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#145#146\", Any, Any}\n\n\nAdd an :initial or :final value constraint on the state.\n\nExamples\n\n# state dimension: 1\njulia> constraint!(ocp, :initial, 0)\njulia> constraint!(ocp, :final, 1)\n\n# state dimension: 2\njulia> constraint!(ocp, :initial, [ 0, 0])\njulia> constraint!(ocp, :final, [ 0, 0])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-3","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\n\n\nAdd a :boundary, :control, :state or :mixed value functional constraint.\n\nExamples\n\njulia> constraint!(ocp, :boundary, (t0, x0, tf, xf) -> [t0+tf, x0[3]+xf[2]], [ 0, 0 ])\n\n# autonomous ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# nonautonomous ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-4","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\n\n\nAdd a :boundary, :control, :state or :mixed box functional constraint.\n\nExamples\n\njulia> constraint!(ocp, :boundary, (t0, x0, tf, xf) -> [t0+tf, x0[3]+xf[2]], [ 0, 0 ], [ 1, 1 ])\n\n# autonomous ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# nonautonomous ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-5","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val\n) -> Tuple{Symbol, Symbol, CTBase.var\"#147#148\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#147#148\", Any, Any}\n\n\nAdd an :initial or :final value constraint on a range of the state.\n\nExamples\n\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-6","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, CTBase.var\"#147#148\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Any, Any, Any}\n\n\nAdd an :initial, :final, :control or :state box constraint on a range.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [1, 2])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [1, 2])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0], [1, 2, 1])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-Union{Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence}, Symbol, Function}} where time_dependence","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{time_dependence},\n    type::Symbol,\n    f::Function\n) -> Any\n\n\nSet the dynamics f(x, u) in the autonomous case and f(t, x, u) in the nonautonomous case.\n\nnote: Note\nThe dimensions of the state and control must be set before adding the dynamics.\nThe dynamics must be provided as a function of time (if ocp is nonautonomous), state and control.\nThe output of the dynamics must be of same dimension as the state (scalar if the state is of dimension 1).\n\nExample\n\njulia> constraint!(ocp, :dynamics, f)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint-Tuple{OptimalControlModel{:autonomous}, Symbol}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{:autonomous},\n    label::Symbol\n) -> Function\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    names::Union{String, Vector{String}}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, [ \"v₁\", \"v₂\" ])\njulia> ocp.control_dimension\n2\njulia> ocp.control_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.isautonomous-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.isautonomous","text":"isautonomous(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isautonomous-Tuple{Symbol}","page":"Model","title":"CTBase.isautonomous","text":"isautonomous(time_dependence::Symbol) -> Bool\n\n\nReturn !isnonautonomous(time_dependence)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.ismax-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.ismax","text":"ismax(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.ismin-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.ismin","text":"ismin(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isnonautonomous-Tuple{Symbol}","page":"Model","title":"CTBase.isnonautonomous","text":"isnonautonomous(time_dependence::Symbol) -> Bool\n\n\nReturn :nonautonomous == time_dependence\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isnonautonomous-Union{Tuple{OptimalControlModel{time_dependence}}, Tuple{time_dependence}} where time_dependence","page":"Model","title":"CTBase.isnonautonomous","text":"isnonautonomous(\n    ocp::OptimalControlModel{time_dependence}\n) -> Bool\n\n\nReturn true if the model has been defined as nonautonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.nlp_constraints-Union{Tuple{OptimalControlModel{time_dependence}}, Tuple{time_dependence}} where time_dependence","page":"Model","title":"CTBase.nlp_constraints","text":"nlp_constraints(\n    ocp::OptimalControlModel{time_dependence}\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#167\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#168\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#169\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#170\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(ulb, uind, uub) are control linear constraints of a subset of indices\n(xlb, xind, xub) are state linear constraints of a subset of indices\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), \n    (ulb, uind, uub), (xlb, xind, xub) = nlp_constraints(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence}, Symbol, Function, Function}, Tuple{OptimalControlModel{time_dependence}, Symbol, Function, Function, Symbol}} where time_dependence","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{time_dependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n) -> Lagrange\nobjective!(\n    ocp::OptimalControlModel{time_dependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n) -> Lagrange\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nThe dimensions of the state and control must be set before adding the dynamics.\n\nExample\n\njulia> objective!(ocp, :bolza, (t0, x0, tf, xf) -> tf, (x, u) -> x[1]^2 + u[1]^2) \n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence}, Symbol, Function}, Tuple{OptimalControlModel{time_dependence}, Symbol, Function, Symbol}} where time_dependence","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{time_dependence},\n    type::Symbol,\n    f::Function\n) -> Any\nobjective!(\n    ocp::OptimalControlModel{time_dependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n) -> Any\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nThe dimensions of the state and control must be set before adding the dynamics.\n\nExamples\n\njulia> objective!(ocp, :mayer, (t0, x0, tf, xf) -> tf)\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u[1]^2)\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(\n    ocp::OptimalControlModel,\n    label::Symbol\n) -> Dict{Symbol, Tuple}\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    names::Union{String, Vector{String}}\n)\n\n\nDefine the state dimension and possibly the names of each coordinate.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, [ \"y₁\", \"y₂\" ])\njulia> ocp.state_dimension\n2\njulia> ocp.state_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n)\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n)\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nnote: Note\nYou can use time! once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, [0, 1])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [0, 1], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [0, 1], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-2","page":"Model","title":"CTBase.time!","text":"time!(ocp::OptimalControlModel, type::Symbol, time::Real)\ntime!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    time::Real,\n    name::String\n)\n\n\nFix initial (resp. final) time, the final (resp. initial) time being variable (free), when type is :initial. And conversely when type is :final. \n\nnote: Note\nYou can use time! once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, :initial, 0)\njulia> ocp.initial_time\n0\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, :initial, 0, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, :initial, 0, :s)\njulia> ocp.initial_time\n0\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, :final, 1)\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, :final, 1, \"s\")\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, :final, 1, :s)\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"api-default.html","page":"Default","title":"Default","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-default.html","page":"Default","title":"Default","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"default.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#CTBase.Ad-Tuple{Any, Any}","page":"Utils","title":"CTBase.Ad","text":"Ad(X, f) -> CTBase.var\"#129#130\"\n\n\nLie derivative of f along X.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.Poisson-Tuple{Any, Any}","page":"Utils","title":"CTBase.Poisson","text":"Poisson(f, g) -> CTBase.var\"#fg#133\"\n\n\nReturn the Poisson bracket of f and g.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctindices-Tuple{Integer}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctupperscripts-Tuple{Integer}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-to-the-CTBase.jl-package","page":"Introduction","title":"Introduction to the CTBase.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install a package from the control-toolbox ecosystem, please visit the installation page.","category":"page"}]
}
